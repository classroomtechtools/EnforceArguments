<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      Home - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li  class="active" >
        <a href="index.html">
          
          
            <svg fill="#178232" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      Unit Testing for Google appsScripts (Utgs) by Classroom Tech Tools
    </h3>

    

    <h3 id="global-nav">Global</h3><ul><li><a href="global.html#create">create</a></li><li><a href="global.html#named">named</a></li><li><a href="global.html#positional">positional</a></li><li><a href="global.html#throwError_">throwError_</a></li></ul>
  </nav>

  <div id="main">
    

    
      



    

      


  <section class="readme">
    <article>
      <h1>EnforceArguments</h1>
<p>A V8 GAS library which enables the ability for the developer to guarantee that functions receive arguments that match the expected types -- including instances of classes.</p>
<p><img src="enforcearguments.gif?raw=true" alt="" title="EnforcedArguments"></p>
<h2>Quickstart</h2>
<p>Project ID: <code>M4wxut0XaxZerFMk3i2mDVfD8R0iiSsw_</code>, then use like this:</p>
<pre class="prettyprint source lang-js"><code>function Example1 () {
    function UsingPosArgs (a, b=10) {
        Enforce.positional(arguments, {a: '!string', b: 'number'});
    }
    UsingPosArgs('required');  // executes without error
    UsingPosArgs();  // 'TypeError: Required arguments in UsingPosArgs not recieved'
}

function Example2 () {
    function UsingNamedArgs ({a, b=10, c=[]}={}) {
        Enforce.named(arguments, {a: '!string', b: 'number', c: 'array'});
    }
    UsingNamedArgs({a: 'required', c: []});  // executes without error:
    UsingNamedArgs({a: 'required', c: true, f: 'woops'});  // 'TypeError: … Expected array but got string'
}
</code></pre>
<h3>Also available as an npm module</h3>
<p>For those who would are curious about using this package as a module, see last section below.</p>
<h2>Why</h2>
<p>The advantages to guaranteeing that your function parameters are somehow validated become more evident with more complicated usage patterns. As a code base gets bigger, you might have to start tracking down bugs in the code, and that process is helped if …</p>
<ul>
<li>You can assume that required arguments are <em>always</em> present</li>
<li>You can assume that some particular arguments are a particular type</li>
<li>You can also use an argument as <code>null</code> to indicate “nothing”</li>
</ul>
<p>This library lets you …</p>
<ul>
<li>Declare required arguments, which will throw <code>TypeError</code> in their absence</li>
<li>Declare arguments to have particular types, and will throw  <code>TypeError</code> if it isn’t</li>
<li>Enforce arity (number of arguments) and throws <code>TypeError</code> on mismatch</li>
</ul>
<h2>Discussion</h2>
<p>This library …</p>
<ul>
<li>Works for either positional arguments or destructured arguments (which we'll call &quot;named arguments&quot;)</li>
<li>Understands types <code>string</code>, <code>object</code>, <code>number</code>, <code>boolean</code>, <code>array</code> as enforced types, and can even enforce <strong>classes instances</strong>, such as <code>Date</code></li>
<li>Understands type <code>any</code> to indicate bypass type checking</li>
<li>Treats all <code>null</code> values as valid values (type checking is bypassed)</li>
</ul>
<h2>Example</h2>
<p>Declaration is done in (preferably) the first line of the function by passing an object where keys are the name of the arguments, and values are strings that indicate the type. Use <code>!</code> to indicate it is <code>required</code>:</p>
<h3>Positional arguments example</h3>
<pre class="prettyprint source lang-js"><code>function drink (liquid, speed=1) {
    Enforce.positional(arguments, {liquid: '!string', speed: 'number'}, 'drink');
}
drink('water');  // okay, speed = 1
drink(124);      // TypeError wrong type
drink();         // TypeError requires liquid
drink('coke', 'water'); // TypeError too many
</code></pre>
<blockquote>
<p>For <code>Enforce.positional</code>, the programmer needs to declare the keys in the object in the same order they are defined in the function signature.</p>
</blockquote>
<p>This function receives the <code>arguments</code> keyword and an object that defines the expected positional parameters, with their types as strings. These strings should match the <code>typeof</code> result on the passed values.</p>
<p>In case it is called incorrectly, a <code>TypeError</code> is raised. The string <code>&quot;drink&quot;</code> is given to <code>Enforce.positional</code> as the last argument as a (optional) comment that will display when the error is thrown.</p>
<h3>Destructured arguments example</h3>
<p>Works on the same principal above and used in much of the same way.</p>
<pre class="prettyprint source lang-js"><code>function drink({liquid, speed=1}={}) {
    Enforce.named(arguments, {liquid: '!string', speed: 'number'}, 'drink');
}
drink({liquid: 'water'});  // okay, speed = 1
drink({speed: 10});        // TypeError missing &quot;liquid&quot;
drink({nothing: ''});      // TypeError no &quot;nothing&quot; expected
drink();                   // TypeError missing &quot;liquid&quot;
</code></pre>
<blockquote>
<p>The <code>arguments</code> keyword is used to send the arguments actually passed to <code>EnforceArguments</code>, and can't be sensibly be anything else, given the use case</p>
</blockquote>
<p>So, basically, you use <code>Enforce.positional(arguments, ...)</code> inside functions that utilize positional parameters, and <code>Enforce.named(arguments, ...)</code>for those functions using destructured arguments.</p>
<h2>Discussion</h2>
<p>You have a function which is really essential that the arguments passed to it have the right types.</p>
<pre class="prettyprint source lang-js"><code>function importantFunction(id, name, values, check) {
    // does something important
}
</code></pre>
<p>It's just so, so important that <code>id</code> <em>has to be an integer</em>,  <code>name</code> <em>has to be a string</em> and <code>values</code> <em>has to be an array</em>, and <code>check</code> <em>has to be a boolean</em>.</p>
<p>Also, the first three are <strong>required</strong>, but <code>check</code> is not, and if not it's <code>true</code> by default.</p>
<p>If the function is passed anything that doesn't meet the above specification, throw an error that indicates what is missing, or what is wrong.</p>
<p>Required parameters are indicated with <code>!</code> as the first character in the string that declares the type. Using that object, we can use the syntax of <a href="%5Bhttps://davidwalsh.name/destructuring-function-arguments%5D(https://davidwalsh.name/destructuring-function-arguments)">destructuring</a> to our advantage to rewrite <code>importantFunction</code> like so:</p>
<pre class="prettyprint source lang-js"><code>function importantFunction({id, name, values, check=true}={}) {
    Enforce.named(arguments, {id: '!number', name: 'string', values: 'array'}, 'importantFunction');
}
</code></pre>
<p>Now this function is supposed to be invoked in the following manner:</p>
<pre class="prettyprint source lang-js"><code>importantFunction({id: 1234, name: 'name', values: [1,2]});
</code></pre>
<p>But if you forget the <code>id</code>, <code>name</code>, or <code>values</code> parameters, it'll throw a <code>TypeError</code>. If you pass an object of the wrong type, it'll throw an error telling you which type it is expecting.</p>
<p>If you pass it an extra property, for example <code>checked</code> (you misspelled <code>check</code>), it'll also throw a <code>TypeError</code>. You can also pass the arguments in a different order and still be correct:</p>
<pre class="prettyprint source lang-js"><code>importantFunction({name: 'name', values: [1,2], id: 1234);
</code></pre>
<p>Using named arguments that are enforced is more convenient and more readable. The author uses them extensively.</p>
<h2>Motivation</h2>
<p>One motivation is that I far prefer named arguments, and need a convenient way to check for instances of classes, too. In addition to that, type checking and remembering what functions take <em>so much</em> of the developer's mental energy when building and debugging in vanilla JavaScript. In addition, if you're writing a library, you'll be doing your user a favor by throwing errors early if they don't use the API in the intended manner.</p>
<p>Also, while I <em>far</em> prefer using named arguments, GAS libraries expose their functions with positional arguments only. So I used this library to expose library functions, but also lets me write with named arguments:</p>
<pre class="prettyprint source lang-js"><code>const interface =  {id: '!number', name: 'string'};

function internalFunction_({id, name}={}) {
    Enforce.named(arguments, interface);
}

/**
 * @param {Number} id
 * @param {String} name
 */
function exportedFunction(id, name) {
    Enforce.positional(arguments, interface);
    internalFunction_(id);
}
</code></pre>
<h2>Notes &amp; More</h2>
<h3>Performance</h3>
<p>Type checking with positional arguments gets the bigger performance penalty than with using named arguments. <code>Enforce.positional</code> has to do more work in preparation for the checking than <code>Enforce.named</code>.</p>
<p>Naturally, there is additional computation involved with the additional overhead of type checking introduced. Some simple performance tests conducted only indicate a difference of 100 milliseconds at 20K calls for named arguments, but a 200 millisecond penalty for positional arguments.</p>
<p>The author does not see any real risk in slowing it down noticeably for end users.</p>
<p>Beware of Default Values</p>
<p>Use of this library has a limitation involving use of default values , which has to do with how <code>arguments</code> variable works in JavaScript. Consider the following case:</p>
<pre class="prettyprint source lang-js"><code>function someFunc(a=1) {  // default value is a number
  Enforce.positional(arguments, {a: 'string'});  // but we define as a string here
}

// call without any arguments
// a is absent in function call, and so
// &quot;arguments&quot; keyword does not contain anything for `a`
someFunc();  // no error!
</code></pre>
<p>Above, we’ve defined a function with a parameter <code>a</code> that has a default value of <code>1</code>. Yet, we also specify through the interface of <code>Enforce.positional</code> that we are expecting a type <code>string</code>. When we invoke the function, we are expecting it to catch that issue. After all, the variable <code>a</code> will be <code>1</code>, right?</p>
<p>The issue is that the code uses <code>arguments</code> to determine type checks, and when default value is used, that argument is <code>undefined</code> inside of the <code>arguments</code> variable. So there’s now way for <code>Enforce.positional</code> to know that the default value has an incompatible type with it.</p>
<p>The same applies to <code>Enforce.named</code>.</p>
<p>This is a potential gotcha, but one that is not a show-stopper. The programmer has to ensure that the default value is compatible string type that is declared in the interface.</p>
<h3>A Note on <code>null</code> values: Optionals</h3>
<p>The <code>Enforce.*</code> methods consider a <code>null</code> passed value as valid. This means that what we are enforcing are &quot;optional&quot; types, which is quite useful. It means that you can write a function that takes an <code>id</code> as a <code>number</code> argument, which if it really is a number get the thing at that <code>id</code>, but if it's <code>null</code> create a new one.</p>
<pre class="prettyprint source lang-js"><code>function getSpreadsheet({id=null}={}) {
    Enforce.named(arguments, {id: 'number'});  // not required, and so null will be the default
    if (id === null) {
        return SpreadsheetApp.create(…);
    }
    return SpreadsheetApp.openById(id);
}

getSpreadsheet({id: null});
// same as
getSpreadsheet();
</code></pre>
<p>You can also use this method with class methods.</p>
<h3>Applying to class methods</h3>
<p>Same technique applies to class methods. This example simplfies the code so that we're not repeating ourselves.</p>
<pre class="prettyprint source lang-js"><code>const ssConstructorArgs = {id: '!number'};

class Spreadsheet {
    constructor (id) {
        Enforce.positional(arguments, ssConstructorArgs);
        this.id = id;
    }
    static fromId ({id}={}) {
        Enforce.named(arguments, ssConstructorArgs);
        return new Spreadsheet(id);
    }
}
</code></pre>
<h3>Declarative vs Decorate</h3>
<p>The following is an alternative, but more verbose, way of working with this library. You need to use it in a different way to get the same results, but there is more typing involved.</p>
<p>The use case where this method shines is if you have a function where one of the arguments needs to be an instance of a class <strong>and</strong> it is required. Using our above method, this is not possible to do, since we indicate required parameters with a <code>’!’</code> in front, but when asking for class instances, you pass the actual class itself. No room to prepend a string.</p>
<p>How would you declare a function that requires a <code>Date</code> object?</p>
<pre class="prettyprint source lang-js"><code>function NeedDate(date=new Date()) {
    Enforce.positional(arguemnts, {date: Date});  // not indicates as required!
}
</code></pre>
<p>So, we use the this alternative method, which I’m calling the “declarative” option:</p>
<pre class="prettyprint source lang-js"><code>// E for &quot;enforce&quot;; we'll use this object to enforce arguments in below function
const E = Enforce.create({date: Date, info: '!string'});

function getSomething(request=E.req, info) {  // E.req makes it required
  E.enforcePositional(arguments);
    ...
}

// create the instance
const d = new Date();

// now you can use getJson method where the first parameter is checked to ensure it is an instance of Request:
getSomething(d, 'some string (also required)');
</code></pre>
<p>Notice that <code>E.req</code> makes the argument required; leave it out if the parameter is not required. You can use the usual <code>!</code> syntax with <code>info</code> for example, which is demonstrated below:</p>
<pre class="prettyprint source lang-js"><code>const D = Enforce.create({request: Request, info: '!string'});

function getJson(request=D.req, info=D.req) {
    D.enforcePositional(arguments);
}
</code></pre>
<blockquote>
<p>Requiring an argument as in <code>info</code> in the example directly above is not recommended since you'll have to keep the declaration consistent with <code>&quot;!string&quot;</code> declaration anyway.</p>
</blockquote>
<h2></h2>
<h3>Use it as an AppsScripts module</h3>
<p>This is <a href="https://www.npmjs.com/package/@classroomtechtools/enforce_arguments">also available</a> as an npm module. Using <a href="https://github.com/classroomtechtools/appscripts-modules-ft-svelte">this utility</a>, you can install via</p>
<pre class="prettyprint source lang-bash"><code>npm install @classroomtechtools/enforce_arguments
</code></pre>
<p>First you have to write a module:</p>
<pre class="prettyprint source lang-js"><code>// ./src/modules/enforce.js
import {Enforce} from '@classroomtechtools/enforce_arguments';
export {Enforce};
</code></pre>
<p>Then use as a module like this:</p>
<pre class="prettyprint source lang-js"><code>function UsingPosArgs (a, b=10) {
    const {Enforce} = Import;
    Enforce.positional(arguments, {a: '!string', b: 'number'}, 'UsingPosArgs');
}

function UsingNamedArgs ({a, b=10, c, d={}, e=new Date(), f=[]}={}) {
    const {Enforce} = Import;
    Enforce.named(arguments, {a: '!string', b: 'number', c: '!boolean', d: 'object', e: Date, f: 'array'}, 'UsingNamedArgs');
}
</code></pre>
<p>Or, you can navigate <a href="https://github.com/classroomtechtools/EnforceArguments/blob/master/project/Bundle.js">to the source Bundle file</a> and include it in your own project (via copy and paste) if that's what floats your boat.</p>
    </article>
  </section>


    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>